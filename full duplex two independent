#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>

#define FIFO1 "/tmp/fifo1"   // Process1 → Process2
#define FIFO2 "/tmp/fifo2"   // Process2 → Process1
#define BUFFER_SIZE 1024

void analyze(const char *s, int *chars, int *words, int *lines) {
    *chars = strlen(s);
    *lines = 1;
    *words = 0;
    int inWord = 0;
    for (int i = 0; s[i] != '\0'; i++) {
        if (s[i] == '\n') (*lines)++;
        if (isspace((unsigned char)s[i])) {
            inWord = 0;
        } else {
            if (!inWord) {
                inWord = 1;
                (*words)++;
            }
        }
    }
}

int main(void) {
    pid_t pid1, pid2;

    // Create FIFOs
    mkfifo(FIFO1, 0666);
    mkfifo(FIFO2, 0666);

    // Fork Process2 (reader‑analyzer)
    pid2 = fork();
    if (pid2 < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    if (pid2 == 0) {
        // child acting as Process2
        char sentence[BUFFER_SIZE];
        while (1) {
            int fd1 = open(FIFO1, O_RDONLY);
            if (fd1 < 0) { perror("open FIFO1"); exit(EXIT_FAILURE); }
            if (read(fd1, sentence, BUFFER_SIZE) <= 0) {
                close(fd1);
                continue;
            }
            close(fd1);

            if (strcmp(sentence, "exit") == 0) {
                break;
            }

            int chars, words, lines;
            analyze(sentence, &chars, &words, &lines);

            char out[BUFFER_SIZE];
            snprintf(out, BUFFER_SIZE,
                     "Input: %s\nCharacters: %d\nWords: %d\nLines: %d",
                     sentence, chars, words, lines);

            int fd2 = open(FIFO2, O_WRONLY);
            if (fd2 < 0) { perror("open FIFO2"); exit(EXIT_FAILURE); }
            write(fd2, out, strlen(out) + 1);
            close(fd2);
        }
        exit(EXIT_SUCCESS);
    }

    // Fork Process1 (sentence‑writer)
    pid1 = fork();
    if (pid1 < 0) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    if (pid1 == 0) {
        // child acting as Process1
        char sentence[BUFFER_SIZE];
        while (1) {
            printf("Enter sentence (or \"exit\" to quit): ");
            if (!fgets(sentence, BUFFER_SIZE, stdin)) break;
            sentence[strcspn(sentence, "\n")] = '\0';

            int fd1w = open(FIFO1, O_WRONLY);
            if (fd1w < 0) { perror("open FIFO1 write"); exit(EXIT_FAILURE); }
            write(fd1w, sentence, strlen(sentence) + 1);
            close(fd1w);

            if (strcmp(sentence, "exit") == 0) {
                break;
            }

            int fd2r = open(FIFO2, O_RDONLY);
            if (fd2r < 0) { perror("open FIFO2 read"); exit(EXIT_FAILURE); }
            char result[BUFFER_SIZE];
            read(fd2r, result, BUFFER_SIZE);
            close(fd2r);

            printf("Result from Process2:\n%s\n\n", result);
        }
        exit(EXIT_SUCCESS);
    }

    // Parent waits for both children
    wait(NULL);
    wait(NULL);

    // Cleanup FIFOs
    unlink(FIFO1);
    unlink(FIFO2);

    printf("Main: Both processes finished. Exiting.\n");
    return EXIT_SUCCESS;
}
